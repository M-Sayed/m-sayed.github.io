<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="From Minutes to Milliseconds: A Performance Optimization Journey - Technical blog by Mahmoud Sayed">
    <title>From Minutes to Milliseconds: A Performance Optimization Journey - Mahmoud Sayed</title>
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <div class="nav-brand">MS</div>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="index.html#about" class="nav-link">About</a></li>
                <li><a href="index.html#experience" class="nav-link">Experience</a></li>
                <li><a href="index.html#skills" class="nav-link">Skills</a></li>
                <li><a href="index.html#projects" class="nav-link">Projects</a></li>
                <li><a href="index.html#contact" class="nav-link">Contact</a></li>
                <li><a href="blog.html" class="nav-link">Blog</a></li>
            </ul>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <article class="blog-post">
        <a href="blog.html" class="back-to-blog">← Back to Blog</a>
        
        <header class="blog-post-header">
            <h1 class="blog-post-title">From Minutes to Milliseconds: A Performance Optimization Journey</h1>
            <div class="blog-post-meta">
                Published on November 28, 2024 • 12 min read • Performance
            </div>
        </header>

        <div class="blog-post-content">
            <img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2070&q=80" alt="Performance Monitoring Dashboard">

            <p>There's nothing quite like the feeling of transforming a painfully slow query from taking minutes to executing in milliseconds. During my time at Iubenda, I embarked on a performance optimization journey that resulted in 10x faster page load times and 4x improvement in response times. Here's the story of how we achieved these dramatic improvements.</p>

            <h2>The Starting Point: A Performance Nightmare</h2>

            <p>When I joined the team, users were experiencing page load times of 30+ seconds for complex help post searches. The application would sometimes timeout, and the database was constantly under heavy load. Something had to be done.</p>

            <blockquote>
                "Performance is not just about speed—it's about user experience, business value, and system reliability."
            </blockquote>

            <h3>Initial Metrics</h3>

            <ul>
                <li>Average page load time: 32 seconds</li>
                <li>Help post search response: 18 seconds</li>
                <li>Database CPU utilization: 85%</li>
                <li>Cache hit ratio: 12%</li>
            </ul>

            <h2>Step 1: Profiling and Identifying Bottlenecks</h2>

            <p>The first rule of optimization: measure everything. I started by implementing comprehensive profiling across the application stack.</p>

            <img src="https://images.unsplash.com/photo-1460925895917-afdab827c52f?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2015&q=80" alt="Code Performance Analysis">

            <h3>Rails Profiling Setup</h3>

            <pre><code class="language-ruby">class ApplicationController < ActionController::Base
  before_action :start_profiling
  after_action :log_performance_metrics

  private

  def start_profiling
    @start_time = Time.current
    @start_memory = get_memory_usage
  end

  def log_performance_metrics
    duration = Time.current - @start_time
    memory_used = get_memory_usage - @start_memory
    
    Rails.logger.info({
      controller: controller_name,
      action: action_name,
      duration: duration,
      memory_delta: memory_used,
      sql_queries: sql_query_count
    }.to_json)
  end

  def get_memory_usage
    `ps -o rss= -p #{Process.pid}`.to_i
  end
end</code></pre>

            <h3>Database Query Analysis</h3>

            <p>The real culprit was in our database queries. Here's what I discovered:</p>

            <pre><code class="language-sql">-- Original problematic query
SELECT h.*, u.name as author_name, c.name as category_name
FROM help_posts h
LEFT JOIN users u ON h.user_id = u.id
LEFT JOIN categories c ON h.category_id = c.id
WHERE h.content ILIKE '%search_term%'
   OR h.title ILIKE '%search_term%'
   OR u.name ILIKE '%search_term%'
   OR c.name ILIKE '%search_term%'
ORDER BY h.created_at DESC
LIMIT 20;

-- Query plan showed sequential scans across large tables
EXPLAIN ANALYZE SELECT ... 
-- Seq Scan on help_posts h (cost=0.00..45823.45 rows=1234 width=89) 
--   (actual time=0.123..18432.456 rows=1234 loops=1)</code></pre>

            <h2>Step 2: Database Optimization</h2>

            <h3>Strategic Indexing</h3>

            <p>The first major improvement came from intelligent indexing. Instead of generic indexes, I created composite indexes that matched our actual query patterns:</p>

            <pre><code class="language-sql">-- Full-text search indexes
CREATE INDEX idx_help_posts_fulltext ON help_posts 
USING gin(to_tsvector('english', title || ' ' || content));

-- Composite indexes for common filter combinations
CREATE INDEX idx_help_posts_category_date ON help_posts 
(category_id, created_at DESC) WHERE status = 'published';

-- Partial index for active posts only
CREATE INDEX idx_help_posts_active ON help_posts (created_at DESC) 
WHERE status = 'published' AND deleted_at IS NULL;

-- User lookup optimization
CREATE INDEX idx_users_name_lower ON users (LOWER(name));
</code></pre>

            <h3>Query Rewriting</h3>

            <p>The original query was rewritten to leverage PostgreSQL's full-text search capabilities:</p>

            <pre><code class="language-sql">-- Optimized query using full-text search
WITH search_results AS (
  SELECT h.*, 
         ts_rank(to_tsvector('english', h.title || ' ' || h.content), 
                 plainto_tsquery('english', $1)) as rank
  FROM help_posts h
  WHERE h.status = 'published' 
    AND h.deleted_at IS NULL
    AND to_tsvector('english', h.title || ' ' || h.content) 
        @@ plainto_tsquery('english', $1)
)
SELECT sr.*, u.name as author_name, c.name as category_name
FROM search_results sr
JOIN users u ON sr.user_id = u.id
JOIN categories c ON sr.category_id = c.id
ORDER BY sr.rank DESC, sr.created_at DESC
LIMIT 20;

-- Query execution time: 45ms (down from 18 seconds!)</code></pre>

            <h2>Step 3: Strategic Caching Implementation</h2>

            <p>With database queries optimized, the next focus was intelligent caching. I implemented a multi-layer caching strategy:</p>

            <img src="https://images.unsplash.com/photo-1518186233392-c232efbf2373?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80" alt="Caching Architecture">

            <h3>Fragment Caching with Smart Invalidation</h3>

            <pre><code class="language-ruby">class HelpPost < ApplicationRecord
  belongs_to :user
  belongs_to :category
  
  after_save :expire_related_caches
  after_destroy :expire_related_caches

  def cache_key_with_version
    "#{cache_key}/#{cache_version}"
  end

  def cache_version
    [updated_at, user.updated_at, category.updated_at].max.to_i
  end

  private

  def expire_related_caches
    Rails.cache.delete_matched("help_posts/search/*")
    Rails.cache.delete_matched("help_posts/category/#{category_id}/*")
    Rails.cache.delete("help_posts/recent")
  end
end

class HelpPostsController < ApplicationController
  def search
    cache_key = "help_posts/search/#{Digest::MD5.hexdigest(params[:q])}/#{params[:page]}"
    
    @help_posts = Rails.cache.fetch(cache_key, expires_in: 15.minutes) do
      HelpPost.search(params[:q])
              .includes(:user, :category)
              .page(params[:page])
              .per(20)
    end
  end
end</code></pre>

            <h3>Database Query Result Caching</h3>

            <pre><code class="language-ruby">module QueryCache
  extend ActiveSupport::Concern

  class_methods do
    def cached_search(query, options = {})
      cache_key = "#{self.name.underscore}/search/#{Digest::MD5.hexdigest(query)}"
      expires_in = options[:expires_in] || 10.minutes
      
      Rails.cache.fetch(cache_key, expires_in: expires_in) do
        search_without_cache(query, options)
      end
    end
  end
end

class HelpPost < ApplicationRecord
  include QueryCache
  
  def self.search_without_cache(query, options = {})
    # Original search implementation
    where("to_tsvector('english', title || ' ' || content) @@ plainto_tsquery('english', ?)", query)
      .includes(:user, :category)
      .order(created_at: :desc)
  end
end</code></pre>

            <h2>Step 4: Application-Level Optimizations</h2>

            <h3>N+1 Query Elimination</h3>

            <p>One of the most common performance killers in Rails applications is the N+1 query problem. Here's how I systematically eliminated them:</p>

            <pre><code class="language-ruby"># Before: N+1 queries
def show_help_posts
  @help_posts = HelpPost.published.limit(10)
  # This will trigger N queries for users and N queries for categories
end

# After: Proper eager loading
def show_help_posts
  @help_posts = HelpPost.published
                        .includes(:user, :category, :tags)
                        .limit(10)
end

# Advanced: Custom preloading for complex associations
def show_help_posts_with_stats
  @help_posts = HelpPost.published
                        .includes(:user, :category)
                        .preload(:comments, :votes)
                        .limit(10)
  
  # Preload comment counts in a single query
  post_ids = @help_posts.map(&:id)
  comment_counts = Comment.where(help_post_id: post_ids)
                         .group(:help_post_id)
                         .count
  
  @help_posts.each do |post|
    post.instance_variable_set(:@comment_count, comment_counts[post.id] || 0)
  end
end</code></pre>

            <h3>Memory Usage Optimization</h3>

            <pre><code class="language-ruby">class HelpPostsController < ApplicationController
  def export_large_dataset
    # Before: Loading everything into memory
    # posts = HelpPost.all.map(&:to_csv_row) # Memory explosion!
    
    # After: Streaming approach
    send_data generate_csv_stream, 
              filename: "help_posts_#{Date.current}.csv",
              type: 'text/csv'
  end

  private

  def generate_csv_stream
    Enumerator.new do |yielder|
      yielder << CSV.generate_line(['Title', 'Author', 'Created'])
      
      HelpPost.published.find_each(batch_size: 1000) do |post|
        yielder << CSV.generate_line([
          post.title,
          post.user.name,
          post.created_at
        ])
      end
    end.join
  end
end</code></pre>

            <h2>Step 5: Monitoring and Automated Cache Management</h2>

            <p>The final piece was implementing comprehensive monitoring and automated cache management:</p>

            <pre><code class="language-ruby">class CacheManager
  def self.warm_up_critical_caches
    # Warm up frequently accessed data
    Rails.cache.fetch('help_posts/popular', expires_in: 1.hour) do
      HelpPost.popular.includes(:user, :category).limit(50)
    end
    
    Rails.cache.fetch('categories/with_counts', expires_in: 30.minutes) do
      Category.joins(:help_posts)
              .group('categories.id')
              .select('categories.*, COUNT(help_posts.id) as posts_count')
    end
  end

  def self.intelligent_cache_purge
    # Purge old cache entries during off-peak hours
    if Time.current.hour.in?(2..4)
      Rails.cache.cleanup
      Rails.logger.info "Cache cleanup completed at #{Time.current}"
    end
  end
end

# Scheduled job for cache management
class CacheMaintenanceJob < ApplicationJob
  def perform
    CacheManager.warm_up_critical_caches
    CacheManager.intelligent_cache_purge
  end
end</code></pre>

            <img src="https://images.unsplash.com/photo-1551650975-87deedd944c3?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=2074&q=80" alt="Performance Improvement Graphs">

            <h2>The Results: Dramatic Performance Gains</h2>

            <p>After implementing all optimizations, the results were remarkable:</p>

            <h3>Before vs After Metrics</h3>

            <table style="width: 100%; border-collapse: collapse; margin: 2rem 0;">
                <thead>
                    <tr style="background: var(--surface);">
                        <th style="padding: 0.75rem; border: 1px solid var(--border); text-align: left;">Metric</th>
                        <th style="padding: 0.75rem; border: 1px solid var(--border); text-align: left;">Before</th>
                        <th style="padding: 0.75rem; border: 1px solid var(--border); text-align: left;">After</th>
                        <th style="padding: 0.75rem; border: 1px solid var(--border); text-align: left;">Improvement</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">Page Load Time</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">32 seconds</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">3.2 seconds</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border); color: var(--success);">10x faster</td>
                    </tr>
                    <tr style="background: var(--surface);">
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">Search Response</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">18 seconds</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">4.5 seconds</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border); color: var(--success);">4x faster</td>
                    </tr>
                    <tr>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">DB CPU Usage</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">85%</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">35%</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border); color: var(--success);">59% reduction</td>
                    </tr>
                    <tr style="background: var(--surface);">
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">Cache Hit Ratio</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">12%</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border);">87%</td>
                        <td style="padding: 0.75rem; border: 1px solid var(--border); color: var(--success);">7x improvement</td>
                    </tr>
                </tbody>
            </table>

            <h2>Key Lessons Learned</h2>

            <h3>1. Measure First, Optimize Second</h3>

            <p>Without proper profiling, you're optimizing blind. Always establish baseline metrics before making changes.</p>

            <h3>2. Database Optimization Has the Biggest Impact</h3>

            <p>In most web applications, the database is the bottleneck. Focus your optimization efforts here first.</p>

            <h3>3. Caching is an Art, Not a Science</h3>

            <p>Effective caching requires understanding your application's access patterns and user behavior.</p>

            <h3>4. Monitor Everything</h3>

            <p>Performance optimization is an ongoing process. Implement monitoring to catch regressions early.</p>

            <blockquote>
                "The fastest code is the code that never runs. The second fastest is the code that runs efficiently."
            </blockquote>

            <h2>Conclusion</h2>

            <p>Performance optimization is a journey, not a destination. By following a systematic approach—profiling, database optimization, strategic caching, and continuous monitoring—we transformed a slow, frustrating user experience into a fast, responsive application.</p>

            <p>The key is to tackle performance holistically: optimize at the database level, implement intelligent caching, eliminate application bottlenecks, and monitor continuously. Most importantly, always measure the impact of your changes.</p>

            <p>Remember: every millisecond matters to your users. The effort you put into performance optimization directly translates to better user experience and business value.</p>
        </div>
    </article>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 Mahmoud Sayed. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/ruby.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="assets/js/script.js"></script>
</body>
</html>