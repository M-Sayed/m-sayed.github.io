<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://m-sayed.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://m-sayed.github.io/" rel="alternate" type="text/html" /><updated>2025-06-25T22:09:25+03:00</updated><id>https://m-sayed.github.io/feed.xml</id><title type="html">Mahmoud Sayed</title><subtitle>Senior Software Engineer with 8+ years experience in backend development, system architecture, and DevOps. Currently at Accredible, specializing in distributed systems, real-time analytics, and cloud infrastructure. ICPC World Finalist 2017 with expertise in Ruby/Rails, TypeScript, AWS, and performance optimization.</subtitle><entry xml:lang="ar"><title type="html">Open-closed principle</title><link href="https://m-sayed.github.io/ar/2020/04/04/ocp-in-arabic.html" rel="alternate" type="text/html" title="Open-closed principle" /><published>2020-04-04T00:00:00+02:00</published><updated>2020-04-04T00:00:00+02:00</updated><id>https://m-sayed.github.io/ar/2020/04/04/ocp-in-arabic</id><content type="html" xml:base="https://m-sayed.github.io/ar/2020/04/04/ocp-in-arabic.html"><![CDATA[<div dir="rtl">
الـ open-closed principle بيقول إن لو عندنا class، فالكلاس ده يكون غير قابل للتعديل ولكن قابل للتمدد، بمعني إن الكلاس يكون قادر إنه يهندل لوجيك أكتر من غير ما أعدل الكود بتاع الكلاس نفسه.

حاجة زي دي ممكن تتنفذ بعدة طرق، أوضحهم هي الـ dependency injection وده معناه إن لو الكلاس بينفذ لوجيك معين ممكن يتغير بتغير الـ objects اللي بتنفذ اللوجيك ده، فالـ objects دي يستحسن يتعملها depencey injection للكلاس، خلونا نأخد مثال:

<div dir="ltr">
<script src="https://gist.github.com/M-Sayed/66ba9b543f24ace41ad385bc6e39a601.js"></script>
</div>

واضح في المثال اللي فات ده إن اللوجيك اللي بيتنفذ بيعتمد علي الـ object اللي إسمه Paypal، فاللي هيحصل في حالة إننا حبينا نغير ال payment gateway دي لحاجة تانية زي Strip هنضطر إن أحنا نعدل الكلاس Order ونغير من Paypal لـ Strip، تغير الكود ده هو اللي المفروض نتجنبه ولكن في نفس الوقت محتاجين من غير ما نغير الكود إن أحنا نخلي ال Order كلاس يدعم payment gateways أكتر، فحاجة زي دي ممكن تتحق بالـ dependency injection/inversion واللي هو أصلا واحد من مبادئ الـ SOLID، فالكود هيكون بالمنظر ده.

<div dir="ltr">
<script src="https://gist.github.com/M-Sayed/1a322a42ee91d6df1843b4a94bcd5d24.js"></script>
</div>

هل فيه طرق تانية نقدر نحقق بيها مبدأ ال OCP؟ فيه طبعاً وده اللي هنكمله في الجزء التاني من البوست ده.
</div>]]></content><author><name></name></author><category term="ar" /><summary type="html"><![CDATA[الـ open-closed principle بيقول إن لو عندنا class، فالكلاس ده يكون غير قابل للتعديل ولكن قابل للتمدد، بمعني إن الكلاس يكون قادر إنه يهندل لوجيك أكتر من غير ما أعدل الكود بتاع الكلاس نفسه.]]></summary></entry><entry><title type="html">Load balancer VS Reverse Proxy</title><link href="https://m-sayed.github.io/2019/12/29/load-balancer-vs-reverse-proxy.html" rel="alternate" type="text/html" title="Load balancer VS Reverse Proxy" /><published>2019-12-29T00:00:00+02:00</published><updated>2019-12-29T00:00:00+02:00</updated><id>https://m-sayed.github.io/2019/12/29/load-balancer-vs-reverse-proxy</id><content type="html" xml:base="https://m-sayed.github.io/2019/12/29/load-balancer-vs-reverse-proxy.html"><![CDATA[<p>It happens a lot when these two terms come in front of me, and mostly, I say “Oh, no. I forgot again the difference between both of them!”, so here I’m writing what I understand, so it can always be my only reference, and yours definitely if you found it useful. ;)</p>

<hr />

<h2 id="load-balancer">Load Balancer</h2>

<p>Let’s imagine you have that application that is becoming too popular, and in a day you get millions of requests headed to your application’s server, you notice that over time your server is responding with higher latency and a small throughput compared with that large number of requests, that’s definitely going to drive users away from using your app.</p>

<p>Now, you realized that your application can not serve that huge number of requests and you decided to <a href="https://en.wikipedia.org/wiki/Scalability#Horizontal">scale it horizontally</a>, by having multiple servers, but now you have questions, don’t you?</p>

<ol>
  <li>How are the clients supposed to communicate with these servers?</li>
  <li>How will the load be <strong>distributed/balanced</strong> between these servers?</li>
</ol>

<p>And here when a Load balancer intervenes to solve the problem - what a super hero. You can simply imagine a load balancer to be an intermediary piece of software - <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">or hardware</a> - that sits between your clients and your servers, the clients will not be communicating directly with your servers any more, instead, they will communicate with your load balancer.</p>

<p>When a client sends a request, the load balancer sends that request to one of your servers, you wonder, which server? I got many, right? The chosen server is determined by which algorithm you’re using, and some of these algorithms are:</p>
<ol>
  <li>Random</li>
  <li>Round Robin / weighted Round Robin</li>
  <li>Least connections / weighted least connections</li>
</ol>

<p>After we knew what a load balancer really does, let’s write down some of its pros &amp; cons:</p>

<h3 id="advantages">Advantages:</h3>
<ol>
  <li>Your server is no more considered a single point of failure, you got multiple servers running at the same time.</li>
  <li>It will detect if any of the servers is down and divert the requests away from that server, so your clients get more successful responses.</li>
  <li>It could be so helpful if your application requires <a href="https://www.nginx.com/resources/glossary/session-persistence">session persistence</a>.</li>
</ol>

<h3 id="disadvantages">Disadvantages:</h3>
<ol>
  <li>Increased complexity</li>
  <li>One load balancer is considered a single point of failure</li>
</ol>

<hr />

<h2 id="reverse-proxy">Reverse Proxy</h2>

<p>Load balancers seem to be really easier to understand, their name (i.e., load balancer) is so descriptive and tells what they mostly do, right? Then, what are reverse proxies? and why they confuse me?</p>

<p>Reverse Proxy is also an intermediary between your server(s) and your clients, but on the other hand, using them doesn’t necessarily come with having multiple servers, you can set up a reverse proxy even if you have only one server, a reverse proxy is more like your application’s “public face”, It allows you to expose your reverse proxy’s info to your clients instead of your servers’ info, for example, you can expose the reverse proxy’s IP address instead of your servers’ and that will increase security and protect your servers from malicious clients and DDoS attacks.</p>

<p>Simply, A reverse proxy receives requests from the clients and send them to your servers, and receives responses from your server(s) and send them back to your clients.</p>

<h3 id="advantages-1">Advantages</h3>
<ol>
  <li>It increases security
    <ol>
      <li>can be used to protect the server from DDoS attacks</li>
    </ol>
  </li>
  <li>can be used for web acceleration - reducing the time it takes to generate a response and return it to the client - techniques:
    <ol>
      <li>SSL termination</li>
      <li>Caching</li>
      <li>Compression</li>
    </ol>
  </li>
  <li>It can act as a load balancer</li>
</ol>

<h3 id="disadvantages-1">Disadvantages</h3>
<ol>
  <li>It increases complexity</li>
  <li>One reverse proxy is a single point of failure.</li>
</ol>

<h4 id="refs">Refs:</h4>
<p>there are plenty of great references out there, so glad we have <a href="https://youtu.be/iDbyYGrswtg">the Internet</a>.</p>

<ol>
  <li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/">https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/</a></li>
  <li><a href="https://serverfault.com/a/127022">https://serverfault.com/a/127022</a></li>
  <li><a href="https://stackoverflow.com/a/28829633/4643970">https://stackoverflow.com/a/28829633/4643970</a></li>
  <li><a href="https://youtu.be/S8J2fkN2FeI">https://youtu.be/S8J2fkN2FeI</a></li>
  <li><a href="https://github.com/donnemartin/system-design-primer#reverse-proxy-web-server">https://github.com/donnemartin/system-design-primer#reverse-proxy-web-server</a></li>
  <li><a href="https://github.com/donnemartin/system-design-primer#load-balancer">https://github.com/donnemartin/system-design-primer#load-balancer</a></li>
  <li><a href="https://www.jscape.com/blog/load-balancing-algorithms">https://www.jscape.com/blog/load-balancing-algorithms</a></li>
  <li><a href="https://www.nginx.com/resources/glossary/session-persistence">https://www.nginx.com/resources/glossary/session-persistence</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Scalability#Horizontal">https://en.wikipedia.org/wiki/Scalability#Horizontal</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">https://en.wikipedia.org/wiki/Load_balancing_(computing)</a></li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[It happens a lot when these two terms come in front of me, and mostly, I say “Oh, no. I forgot again the difference between both of them!”, so here I’m writing what I understand, so it can always be my only reference, and yours definitely if you found it useful. ;)]]></summary></entry></feed>